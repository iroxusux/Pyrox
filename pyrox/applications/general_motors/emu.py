""""General Motors specific emulation logic generator."""
from . import gm
from pyrox.models.plc import emu


class GmEmulationGenerator(emu.BaseEmulationGenerator):
    """General Motors specific emulation logic generator."""

    controller_type = "GmController"

    base_tags = [
        ('Uninhibit', 'INT', 'Uninhibit mode for the controller.'),
        ('Inhibit', 'INT', 'Inhibit mode for the controller.'),
        ('ToggleInhibit', 'BOOL', 'Toggle inhibit mode for the controller.'),
        ('LocalMode', 'INT', 'Local mode for the controller.'),
        ('DeviceDataSize', 'DINT', 'Size of the device data array.'),
        ('LoopPtr', 'DINT', 'Pointer for the device loop.'),
        ('zz_Demo3D_TestMode', 'BOOL', 'Demo 3D\nEmulation Test Mode\n-----\nREMOVE IF FOUND IN PRODUCTION')
    ]

    @property
    def controller(self) -> gm.GmController:
        return self._controller

    @controller.setter
    def controller(self, value: gm.GmController):
        if value.__class__.__name__ != self.controller_type:
            raise TypeError(f'Controller must be of type {self.controller_type}, got {value.__class__.__name__} instead.')
        self._controller = value

    def _add_base_tags(self) -> None:
        """Add base tags required for emulation."""
        self.logger.debug('Adding base tags for GM emulation...')

        for tag_name, datatype, description in self.base_tags:
            self.add_controller_tag(tag_name, datatype, description=description)

    def _add_base_rungs(self, emu_routine: gm.GmRoutine) -> None:
        """Add base emulation rungs."""
        self.logger.debug('Adding base rungs for GM emulation...')

        emu_routine.add_rung(gm.GmRung(  # Setup rung
            controller=self.controller,
            text='MOV(0,Uninhibit)MOV(4,Inhibit)OTU(zz_Demo3D_TestMode);',
            comment='This routine is auto-generated by Indicon LLC. Do not modify.'
        ))

        emu_routine.add_rung(gm.GmRung(
            controller=self.controller,
            text='XIC(Flash.Norm)OTE(Flash.Fast);',
            comment='Reduce fast flash rate to limit communication issues with the 3d model.'
        ))

        emu_routine.add_rung(gm.GmRung(  # Toggle inhibit and device loop setup
            controller=self.controller,
            text='[XIO(ToggleInhibit)MOV(Uninhibit,LocalMode),XIC(ToggleInhibit)MOV(Inhibit,LocalMode)]SIZE(EnetStorage.DeviceData,0,DeviceDataSize)SUB(DeviceDataSize,1,DeviceDataSize)CLR(LoopPtr);',  # noqa: E501
            comment='Handle toggle inhibit and set up the loop for scanning devices.'
        ))

        emu_routine.add_rung(gm.GmRung(  # Device loop rung
            controller=self.controller,
            text='LBL(Loop)XIC(ToggleInhibit)LES(LoopPtr,DeviceDataSize)ADD(LoopPtr,1,LoopPtr)OTU(EnetStorage.DeviceData[LoopPtr].Connected)OTL(EnetStorage.DeviceData[LoopPtr].LinkStatusAvail)OTL(EnetStorage.DeviceData[LoopPtr].Link.Scanned)JMP(Loop);',  # noqa: E501
            comment='Loop through the devices to force the GM Network model to accept all ethernet connections as "OK".'
        ))

        # Module mode setting
        for module in self.controller.modules:
            # Don't process the local PLC module, this could brick the comms if inhibited and cause the user to download.
            if module.name == 'Local':
                continue
            emu_routine.add_rung(gm.GmRung(
                controller=self.controller,
                text=f'SSV(Module,{module.name},Mode,LocalMode);',
                comment=f'Set the communication mode of module {module.name} to LocalMode.'
            ))

    def _generate_g115_drive_emulation(self) -> None:
        """Generate Siemens G115 drive emulation logic."""
        g115_drives = self.get_modules_by_type('G115Drive')
        self.logger.info('Found %d Siemens G115 drive modules...', len(g115_drives))

        if not g115_drives:
            self.logger.debug('No Siemens G115 drive modules found, skipping emulation generation.')
            return

        # Import required datatypes
        self.schema.add_import_from_file(
            file_location=r'docs\controls\emu\Demo3D_G115D_Drive_DataType.L5X',
            asset_types=['DataTypes']
        )

        cname = self.controller.process_name

        # Add controller tag for drives
        self.add_controller_tag(
            tag_name=f'zz_Demo3D_{cname}_Siemens_Drives',
            datatype='Demo3D_G115D_Drive',
            tag_type='Base',
            dimensions='150',
            constant=False,
            external_access='Read/Write',
            description='Emulation tag for Siemens G115 drives.'
        )

        # Generate drive emulation rungs
        for index, drive in enumerate(g115_drives):

            pname = drive.process_name

            i1 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.StatusWord1,{pname}:I.Data[0],1)'
            i2 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.RPMRef,{pname}:I.Data[1],1)'
            i3 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.AmpsRef,{pname}:I.Data[2],1)'
            i4 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.TorqueRef,{pname}:I.Data[3],1)'
            i5 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.FaultCode,{pname}:I.Data[5],1)'
            i6 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.StatusWord4,{pname}:I.Data[6],1)'
            i7 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.SpareInt1,{pname}:I.Data[7],1)'
            i8 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.PowerUnitTempC,{pname}:I.Data[8],1)'
            i9 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.StatusWord5,{pname}:I.Data[9],1)'
            i10 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.MotorTempC,{pname}:I.Data[10],1)'
            i11 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.SafetySTO_Out,{pname}:I.Data[11],1)'
            i12 = f'CPS(zz_Demo3D_{cname}_Siemens_Drives[{index}].Inputs.SafetySTOSts,{pname}:I.Data[12],1)'
            i13 = f'CPS({pname}:O.Data[0],zz_Demo3D_{cname}_Siemens_Drives[{index}].Outputs.ControlWord1,1)'
            i14 = f'CPS({pname}:O.Data[1],zz_Demo3D_{cname}_Siemens_Drives[{index}].Outputs.Setpoint,1)'

            rung_text = f'[{i1}{i2}{i3},{i4}{i5},{i6}{i7}{i8},{i9}{i10}{i11},{i12},{i13}{i14}];'

            self._emu_routine.add_rung(gm.GmRung(
                controller=self.controller,
                text=rung_text,
                comment='Move the emulation populated data to the hardware connection points.'
            ))

    def _generate_hmi_card_emulation(self) -> None:
        """Generate HMI card emulation logic."""
        hmi_cards = self.get_modules_by_description_pattern('<@TYPE 502xSlot1>')
        hmi_cards = [x for x in hmi_cards if x.type_ == 'AB_1734IB8S']
        self.logger.info('Found %d AB 1734IB8S HMI modules...', len(hmi_cards))

        if not hmi_cards:
            return

        # Import required datatypes
        self.schema.add_import_from_file(
            file_location=r'docs\controls\emu\Demo3D_HMI_IN_DataType.L5X',
            asset_types=['DataTypes']
        )
        self.schema.add_import_from_file(
            file_location=r'docs\controls\emu\Demo3D_HMI_OUT_DataType.L5X',
            asset_types=['DataTypes']
        )
        self.schema.add_import_from_file(
            file_location=r'docs\controls\emu\Demo3D_CommOK_HMI_DataType.L5X',
            asset_types=['DataTypes']
        )

        # Generate generic comm word
        self.add_controller_tag(
            tag_name=f'zz_Demo3D_Comm_{self.controller.process_name}HMI',
            tag_type='Base',
            datatype='Demo3D_CommOK_HMI',
            constant=False,
            external_access='Read/Write'
        )

        # Generate HMI emulation logic
        for card in hmi_cards:
            std_tag = self.add_controller_tag(
                tag_name=f'zz_Demo3D_{card.parent_module}_I',
                class_='Standard',
                tag_type='Base',
                datatype='Demo3D_HMI_IN',
                constant=False,
                external_access='Read/Write'
            )

            sfty_tag = self.add_controller_tag(
                tag_name=f'sz_Demo3D_{card.parent_module}_I',
                class_='Safety',
                tag_type='Base',
                datatype='Demo3D_HMI_IN',
                constant=False,
                external_access='Read/Write'
            )

            self.add_controller_tag(
                tag_name=f'zz_Demo3D_{card.parent_module}_O',
                tag_type='Base',
                datatype='Demo3D_HMI_OUT',
                constant=False,
                external_access='Read/Write'
            )

            # Add safety tag mapping to schema
            self.schema.add_safety_tag_mapping(
                std_tag.name,
                sfty_tag.name,
            )

            self._emu_routine.add_rung(gm.GmRung(
                controller=self.controller,
                text=f'CLR({card.parent_module}:2:I.Fault)MOV(sz_Demo3D_{card.parent_module}_I.S2.Word1,{card.parent_module}:2:I.Data);',
                comment='Clear the fault and move the data from the HMI card to the input data.'
            ))

            instr1 = f'COP({card.parent_module}:1:O,zz_Demo3D_{card.parent_module}_O.S1,1)'
            instr2 = f'COP({card.parent_module}:2:O,zz_Demo3D_{card.parent_module}_O.S2,1)'
            self._emu_routine.add_rung(gm.GmRung(
                controller=self.controller,
                text=f'{instr1}{instr2};',
                comment='Map output data from physical card to emulation card.'
            ))

            # Add to safety emulation routine
            self._s_emu_routine.add_rung(gm.GmRung(
                controller=self.controller,
                text=f'COP(sz_Demo3D_{card.parent_module}_I,{card.parent_module}:1:I,1);',
                comment='Copy the input data from the emulation tag to the safety input card.'
            ))

    def _generate_safety_block_emulation(self) -> None:
        """Generate safety block emulation logic."""
        sbks = self.get_modules_by_type('AB_1732EsSafetyBlock')
        self.logger.info('Found %d AB 1732ES Safety Block modules...', len(sbks))

        if not sbks:
            return

        # Import required datatypes
        self.schema.add_import_from_file(
            file_location=r'docs\controls\emu\Demo3D_WDint_DataType.L5X',
            asset_types=['DataTypes']
        )
        self.schema.add_import_from_file(
            file_location=r'docs\controls\emu\Demo3D_CommOK_SBK_DataType.L5X',
            asset_types=['DataTypes']
        )

        # Generate generic comm word
        self.add_controller_tag(
            tag_name=f'zz_Demo3D_Comm_{self.controller.process_name}SBK',
            tag_type='Base',
            datatype='Demo3D_CommOK_SBK',
            constant=False,
            external_access='Read/Write'
        )

        # Generate safety block emulation logic
        for module in sbks:
            # Add standard input tag
            std_tag = self.add_controller_tag(
                tag_name=f'zz_Demo3D_{module.name}_I',
                class_='Standard',
                tag_type='Base',
                datatype='Demo3D_WDint',
                constant=False,
                external_access='Read/Write'
            )

            # Add safe input tag
            sfty_tag = self.add_controller_tag(
                tag_name=f'sz_Demo3D_{module.name}_I',
                class_='Safety',
                tag_type='Base',
                datatype='Demo3D_WDint',
                constant=False,
                external_access='Read/Write'
            )

            # Add output tag
            self.add_controller_tag(
                tag_name=f'zz_Demo3D_{module.name}_O',
                tag_type='Base',
                datatype='DINT',
                constant=False,
                external_access='Read/Write'
            )

            # Add safety tag mapping to schema
            self.schema.add_safety_tag_mapping(
                std_tag.name,
                sfty_tag.name,
            )

            # Add to main emulation routine
            self._emu_routine.add_rung(gm.GmRung(
                controller=self.controller,
                text=f'[XIO(zz_Demo3D_{module.name}_I.Word1.0),XIC(zz_Demo3D_{module.name}_I.Word1.1)]FLL(0,zz_Demo3D_{module.name}_I.Word2,2);',  # noqa: E501
                comment='If communication status is lost to the SBK via the emulation model, zero out the SBK words.'
            ))
            self._emu_routine.add_rung(gm.GmRung(
                controller=self.controller,
                text=f'COP({module.name}:O,zz_Demo3D_{module.name}_O,1);',
                comment='Copy the output data from the safety block to the emulation tag.'
            ))

            # Add to safety emulation routine
            self._s_emu_routine.add_rung(gm.GmRung(
                controller=self.controller,
                text=f'COP(sz_Demo3D_{module.name}_I,{module.name}:I,1);',
                comment='Copy the input data from the emulation tag to the safety block.'
            ))

    def _remove_base_tags(self) -> None:
        """Remove base tags required for emulation."""
        self.logger.debug('Removing base tags for GM emulation...')

        for tag_name, _, _ in self.base_tags:
            self.remove_controller_tag(
                tag_name
            )

    def _remove_all_demo_tags(self) -> None:
        for tag in list(self.controller.tags):
            if tag.name.startswith('zz_Demo3D_') or tag.name.startswith('sz_Demo3D_'):
                self.remove_controller_tag(tag.name)

    def _remove_emulation_routines(self) -> None:
        """Remove emulation routines."""
        self.logger.debug('Removing emulation routines...')
        self.remove_routine(
            self.controller.mcp_program.name,
            'aaa_Emulation'
        )
        self.remove_routine(
            self.controller.safety_common_program.name,
            's_aaa_Emulation'
        )

    def _remove_g115_drive_emulation(self) -> None:
        """Remove Siemens G115 drive emulation logic."""
        g115_drives = self.get_modules_by_type('G115Drive')
        self.logger.info('Found %d Siemens G115 drive modules...', len(g115_drives))

        if not g115_drives:
            self.logger.debug('No Siemens G115 drive modules found, skipping emulation removal.')
            return

        # Remove controller tag for drives
        self.remove_controller_tag(
            tag_name=f'zz_Demo3D_{self.controller.process_name}_Siemens_Drives'
        )

        # Remove drive emulation datatype
        self.remove_datatype('Demo3D_G115D_Drive')

    def _remove_hmi_card_emulation(self) -> None:
        """Remove HMI card emulation logic."""
        hmi_cards = self.get_modules_by_description_pattern('<@TYPE 502xSlot1>')
        hmi_cards = [x for x in hmi_cards if x.type_ == 'AB_1734IB8S']
        self.logger.info('Found %d AB 1734IB8S HMI modules...', len(hmi_cards))

        if not hmi_cards:
            return

        # Remove generic comm word
        self.remove_controller_tag(
            tag_name=f'zz_Demo3D_Comm_{self.controller.process_name}HMI'
        )

        # Remove HMI emulation logic
        for card in hmi_cards:
            self.remove_controller_tag(
                tag_name=f'zz_Demo3D_{card.parent_module}_I'
            )
            self.remove_controller_tag(
                tag_name=f'sz_Demo3D_{card.parent_module}_I'
            )
            self.remove_controller_tag(
                tag_name=f'zz_Demo3D_{card.parent_module}_O'
            )

        # Remove HMI emulation datatypes
        self.remove_datatype('Demo3D_HMI_IN')
        self.remove_datatype('Demo3D_HMI_OUT')
        self.remove_datatype('Demo3D_CommOK_HMI')

        # Remove safety tag mappings
        for card in hmi_cards:
            self.schema.remove_safety_tag_mapping(
                f'zz_Demo3D_{card.parent_module}_I',
                f'sz_Demo3D_{card.parent_module}_I'
            )

    def _remove_safety_block_emulation(self) -> None:
        """Remove safety block emulation logic."""
        sbks = self.get_modules_by_type('AB_1732EsSafetyBlock')
        self.logger.info('Found %d AB 1732ES Safety Block modules...', len(sbks))

        if not sbks:
            return

        # Remove generic comm word
        self.remove_controller_tag(
            tag_name=f'zz_Demo3D_Comm_{self.controller.process_name}SBK'
        )

        # Remove safety block emulation logic
        for module in sbks:
            self.remove_controller_tag(
                tag_name=f'zz_Demo3D_{module.name}_I'
            )
            self.remove_controller_tag(
                tag_name=f'sz_Demo3D_{module.name}_I'
            )
            self.remove_controller_tag(
                tag_name=f'zz_Demo3D_{module.name}_O'
            )

        # Remove safety block emulation datatypes
        self.remove_datatype('Demo3D_WDint')
        self.remove_datatype('Demo3D_CommOK_SBK')

        # Remove safety tag mappings
        for module in sbks:
            self.schema.remove_safety_tag_mapping(
                f'zz_Demo3D_{module.name}_I',
                f'sz_Demo3D_{module.name}_I'
            )

    def generate_base_emulation(self) -> None:
        """Generate base GM emulation logic."""
        self.logger.info("Generating base GM emulation logic...")

        # Add base program tags
        self._add_base_tags()

        # Create main emulation routine
        self._emu_routine = self.add_emulation_routine(
            program_name=self.controller.mcp_program.name,
            routine_name='aaa_Emulation',
            routine_description=''.join([
                'Emulation routine for GM controller.\n',
                'This routine is auto-generated by Indicon LLC.\n',
                'Do not modify.'
            ])
        )

        # Add base emulation rungs
        self._add_base_rungs(self._emu_routine)

        # Create safety emulation routine
        self._s_emu_routine = self.add_emulation_routine(
            program_name=self.controller.safety_common_program.name,
            routine_name='s_aaa_Emulation',
            routine_description=''.join([
                'Emulation routine for GM controller in safety context.\n',
                'This routine is auto-generated by Indicon LLC.\n',
                'Do not modify.'
            ]),
            rung_position=0  # Insert at beginning for safety
        )

    def generate_module_emulation(self) -> None:
        """Generate module-specific emulation logic."""
        self.logger.info("Generating GM module-specific emulation logic...")

        self._generate_g115_drive_emulation()
        self._generate_hmi_card_emulation()
        self._generate_safety_block_emulation()

    def get_modules_by_type(self, module_type) -> list[gm.GmModule]:
        return super().get_modules_by_type(module_type)

    def remove_base_emulation(self):
        self.logger.info("Removing base GM emulation logic...")
        self._remove_base_tags()
        self._remove_emulation_routines()

    def remove_custom_logic(self):
        self._remove_all_demo_tags()

    def remove_module_emulation(self):
        self.logger.info("Removing GM module-specific emulation logic...")
        self._remove_g115_drive_emulation()
        self._remove_hmi_card_emulation()
        self._remove_safety_block_emulation()

    def validate_controller(self) -> bool:
        """Validate that this is a valid GM controller."""
        if not self.controller.mcp_program:
            raise ValueError('No MCP program found in the controller.')

        if not self.controller.mcp_program.main_routine:
            raise ValueError('No main routine found in the MCP program.')

        if not self.controller.safety_common_program:
            raise ValueError('No safety common program found in the controller.')

        if not self.controller.safety_common_program.main_routine:
            raise ValueError('No main routine found in the safety common program.')

        return True

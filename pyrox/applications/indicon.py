"""Indicon default application package implimentations.
This package contains the default controller, validator, and emulation generator
for Indicon PLCs.
"""
from pyrox.models import emu, eplan, plc
from typing import Optional, Self


class BaseControllerValidator(plc.ControllerValidator):
    """Validator for controllers."""
    supporting_class = 'Controller'

    @classmethod
    def validate_all(
        cls,
        controller: plc.Controller
    ) -> Self:
        cls.logger.info('Starting Indicon controller validation...')
        super().validate_all(controller)


class BaseEmulationGenerator(emu.EmulationGenerator):
    """Base class for emulation logic generators."""
    supporting_class = 'Controller'

    def __init__(
        self,
        controller: plc.Controller
    ) -> None:
        super().__init__(controller)

    @property
    def base_tags(self) -> list[str]:
        """List of base tags common to all controllers.

        Returns:
            list[str]: List of tuples (tag_name, datatype, description)
        """
        return [
            ('zz_Demo3D_Uninhibit', 'INT', 'Uninhibit mode for the controller.'),
            ('zz_Demo3D_Inhibit', 'INT', 'Inhibit mode for the controller.'),
            ('zz_Demo3D_ToggleInhibit', 'BOOL', 'Toggle inhibit mode for the controller.'),
            ('zz_Demo3D_LocalMode', 'INT', 'Local mode for the controller.'),
            ('zz_Demo3D_TestMode', 'BOOL', 'Demo 3D\nEmulation Test Mode\n-----\nREMOVE IF FOUND IN PRODUCTION'),
        ]

    @property
    def custom_tags(self) -> list[tuple[str, str, str, Optional[str]]]:
        """List of custom tags specific to the controller type.

        Returns:
            list[str]: List of tuples (tag_name, datatype, description, dimensions).
        """
        raise NotImplementedError("Subclasses must implement custom_tags")

    @property
    def emulation_safety_routine_description(self) -> str:
        """Description for the safety routine to add emulation logic to.

        Returns:
            str: Description of the safety routine
        """
        return self.emulation_standard_routine_description

    @property
    def emulation_safety_routine_name(self) -> str:
        """Name of the safety routine to add emulation logic to.

        Returns:
            str: Name of the safety routine
        """
        return 'zzz_s_Emulation'

    @property
    def emulation_standard_routine_description(self) -> str:
        """Description for the standard routine to add emulation logic to.

        Returns:
            str: Description of the standard routine
        """
        return ''.join([
            'Emulation routine for automation controller.\n',
            'This routine is auto-generated by Indicon LLC.\n',
            'Do not modify.'
        ])

    @property
    def emulation_standard_routine_name(self) -> str:
        """Name of the standard routine to add emulation logic to.

        Returns:
            str: Name of the standard routine
        """
        return 'zzz_Emulation'

    @property
    def generator_object(self) -> plc.Controller:
        return self._generator_object

    @generator_object.setter
    def generator_object(self, value: plc.Controller):
        if value.__class__.__name__ != self.supporting_class:
            raise TypeError(f'Controller must be of type {self.supporting_class}, got {value.__class__.__name__} instead.')
        self._generator_object = value

    @property
    def target_safety_program_name(self) -> str:
        """Name of the safety program to add emulation logic to.

        Returns:
            str: Name of the safety program
        """
        raise NotImplementedError("Subclasses must implement target_safety_program_name")

    @property
    def target_standard_program_name(self) -> str:
        """Name of the standard program to add emulation logic to.

        Returns:
            str: Name of the standard program
        """
        raise NotImplementedError("Subclasses must implement target_standard_program_name")

    @property
    def test_mode_tag(self) -> str:
        """Name of the test mode tag.

        Returns:
            str: Name of the test mode tag
        """
        return self.base_tags[4][0]

    @property
    def toggle_inhibit_tag(self) -> str:
        """Name of the toggle inhibit tag.

        Returns:
            str: Name of the toggle inhibit tag
        """
        return self.base_tags[2][0]


class BaseEplanProject(eplan.project.EplanProject):
    """Base class for Eplan project generation logic."""
    supporting_class = 'Controller'


class BaseEplanValidator(eplan.project.EplanControllerValidator):
    """Base class for Eplan project validation logic."""
    supporting_class = 'Controller'

    def _find_missing_devices_in_project(self):
        self.logger.info('Checking for missing devices in Eplan project...')
        all_devices = [d for d in self.project.devices]
        for device in self.project.devices:
            matching_device = self.find_matching_device_in_controller(device)
            if matching_device:
                all_devices.remove(device)
                continue

            almost_matching_device = self.find_almost_matching_device_in_controller(device)
            if almost_matching_device:
                self.logger.warning(
                    f'Device {device.name} in Eplan project almost matches module {almost_matching_device.name} in controller.'
                    'Check for configuration differences.'
                )
                all_devices.remove(device)

                continue

            self.logger.error(f'Device {device.name} in Eplan project is missing from controller.')

    def _find_missing_modules_in_controller(self):
        self.logger.info('Checking for missing modules in controller...')
        all_modules = [m for m in self.controller.modules]
        for module in self.controller.modules:
            matching_device = self.find_matching_module_in_project(module)
            if matching_device:
                all_modules.remove(module)
                continue

            almost_matching_device = self.find_almost_matching_module_in_project(module)
            if almost_matching_device:
                self.logger.warning(
                    f'Module {module.name} in controller almost matches device {almost_matching_device.name} in Eplan project.'
                    'Check for configuration differences.'
                )
                all_modules.remove(module)

                continue

            self.logger.error(f'Module {module.name} in controller is missing from Eplan project.')

    def _find_missing_devices(self):
        if len(self.project.devices) > len(self.controller.modules):
            self._find_missing_devices_in_project()
        else:
            self._find_missing_modules_in_controller()

    def _validate_controller_properties(self):
        self.logger.info('Validating controller properties...')

    def _validate_modules(self):
        self.logger.info('Validating controller modules...')
        if len(self.project.devices) != len(self.controller.modules):
            self._find_missing_devices()

"""Emulation Generator module for pyrox applications.
"""
from abc import abstractmethod
from typing import Optional, Self, List

from . import plc, mod
from .. import abc


class EmulationGeneratorFactory(abc.MetaFactory):
    """Factory for creating EmulationGenerator instances."""


class EmulationGenerator(abc.PyroxObject, metaclass=abc.FactoryTypeMeta[Self, EmulationGeneratorFactory]):
    """Base class for emulation logic generators."""
    generator_type = 'Controller'

    def __init__(
        self,
        controller: plc.Controller
    ) -> None:
        super().__init__()
        self.generator_object: plc.Controller = controller
        self.schema = plc.ControllerModificationSchema(
            source=None,
            destination=self.generator_object
        )
        self.emu_routine: Optional[plc.Routine] = None
        self.safety_emu_routine: Optional[plc.Routine] = None

    @property
    def base_tags(self) -> list[str]:
        """List of base tags common to all controllers.

        Returns:
            list[str]: List of tuples (tag_name, datatype, description)
        """
        return [
            ('zz_Demo3D_Uninhibit', 'INT', 'Uninhibit mode for the controller.'),
            ('zz_Demo3D_Inhibit', 'INT', 'Inhibit mode for the controller.'),
            ('zz_Demo3D_ToggleInhibit', 'BOOL', 'Toggle inhibit mode for the controller.'),
            ('zz_Demo3D_LocalMode', 'INT', 'Local mode for the controller.'),
            ('zz_Demo3D_TestMode', 'BOOL', 'Demo 3D\nEmulation Test Mode\n-----\nREMOVE IF FOUND IN PRODUCTION'),
        ]

    @property
    def custom_tags(self) -> list[tuple[str, str, str, Optional[str]]]:
        """List of custom tags specific to the controller type.

        Returns:
            list[str]: List of tuples (tag_name, datatype, description, dimensions).
        """
        raise NotImplementedError("Subclasses must implement custom_tags")

    @property
    def emulation_safety_routine_description(self) -> str:
        """Description for the safety routine to add emulation logic to.

        Returns:
            str: Description of the safety routine
        """
        return self.emulation_standard_routine_description

    @property
    def emulation_safety_routine_name(self) -> str:
        """Name of the safety routine to add emulation logic to.

        Returns:
            str: Name of the safety routine
        """
        return 'zzz_s_Emulation'

    @property
    def emulation_standard_routine_description(self) -> str:
        """Description for the standard routine to add emulation logic to.

        Returns:
            str: Description of the standard routine
        """
        return ''.join([
            'Emulation routine for automation controller.\n',
            'This routine is auto-generated by Indicon LLC.\n',
            'Do not modify.'
        ])

    @property
    def emulation_standard_routine_name(self) -> str:
        """Name of the standard routine to add emulation logic to.

        Returns:
            str: Name of the standard routine
        """
        return 'zzz_Emulation'

    @property
    def generator_object(self) -> plc.Controller:
        return self._generator_object

    @generator_object.setter
    def generator_object(self, value: plc.Controller):
        if value.__class__.__name__ != self.generator_type:
            raise TypeError(f'Controller must be of type {self.generator_type}, got {value.__class__.__name__} instead.')
        self._generator_object = value

    @property
    def target_safety_program_name(self) -> str:
        """Name of the safety program to add emulation logic to.

        Returns:
            str: Name of the safety program
        """
        raise NotImplementedError("Subclasses must implement target_safety_program_name")

    @property
    def target_standard_program_name(self) -> str:
        """Name of the standard program to add emulation logic to.

        Returns:
            str: Name of the standard program
        """
        raise NotImplementedError("Subclasses must implement target_standard_program_name")

    @property
    def test_mode_tag(self) -> str:
        """Name of the test mode tag.

        Returns:
            str: Name of the test mode tag
        """
        return self.base_tags[4][0]

    @classmethod
    def get_class(cls) -> Self:
        return cls

    @classmethod
    def get_factory(cls):
        return EmulationGeneratorFactory

    def _add_to_safety_routine(self, rung: plc.Rung) -> None:
        """Helper to add a rung to the safety emulation routine."""
        if not self.safety_emu_routine:
            raise ValueError("Safety emulation routine has not been created yet.")

        self.schema.add_rung(
            program_name=self.target_safety_program_name,
            routine_name=self.emulation_safety_routine_name,
            new_rung=rung
        )

    def _add_rung_to_standard_routine(self, rung: plc.Rung) -> None:
        """Helper to add a rung to the standard emulation routine."""
        if not self.emu_routine:
            raise ValueError("Emulation routine has not been created yet.")

        self.schema.add_rung(
            program_name=self.target_standard_program_name,
            routine_name=self.emulation_standard_routine_name,
            new_rung=rung
        )

    def _generate_base_emulation(self) -> None:
        """Generate the base emulation logic common to all controllers."""
        self._generate_base_tags()
        self._generate_custom_tags()

        self._generate_base_standard_routine()
        self._generate_base_standard_rungs()

        self._generate_base_safety_routine()
        self._generate_base_safety_rungs()

        self._generate_base_module_emulation()

        self._generate_custom_standard_routines()
        self._generate_custom_standard_rungs()
        self._generate_custom_safety_routines()
        self._generate_custom_safety_rungs()

    def _generate_base_module_emulation(self) -> None:
        """Generate base module emulation logic common to all controllers."""
        self._generate_builtin_common(plc.ModuleControlsType.BLOCK)
        self._generate_builtin_common(plc.ModuleControlsType.SAFETY_BLOCK)
        self._generate_builtin_common(plc.ModuleControlsType.DRIVE)

    def _generate_base_safety_routine(self) -> None:
        """Generate a safety routine common to all controllers."""
        self.logger.debug("Generating base safety routine")
        self.safety_emu_routine = self.add_emulation_routine(
            program_name=self.target_safety_program_name,
            routine_name=self.emulation_safety_routine_name,
            routine_description=self.emulation_safety_routine_description,
            call_from_main=True,
            rung_position=0
        )

    def _generate_base_safety_rungs(self) -> None:
        """Generate base rungs in the safety emulation routine."""
        if not self.safety_emu_routine:
            raise ValueError("Safety emulation routine has not been created yet.")

        self.safety_emu_routine.clear_rungs()
        self.logger.debug("Generating base safety rungs")

        # Header rung
        header_rung = plc.Rung(
            controller=self.controller,
            text='NOP();',
            comment='// Emulation Safety Logic Routine\n// Auto-generated by Indicon LLC\n// Do not modify.'
        )
        self._add_to_safety_routine(header_rung)

    def _generate_base_standard_routine(self) -> None:
        """Generate a standard base routine common to all controllers."""
        self.logger.info("Generating base standard routine")
        self.emu_routine = self.add_emulation_routine(
            program_name=self.target_standard_program_name,
            routine_name=self.emulation_standard_routine_name,
            routine_description=self.emulation_standard_routine_description,
            call_from_main=True,
            rung_position=0
        )

    def _generate_base_standard_rungs(self) -> None:
        """Generate base rungs in the standard emulation routine."""
        if not self.emu_routine:
            raise ValueError("Emulation routine has not been created yet.")

        self.emu_routine.clear_rungs()
        self.logger.debug("Generating base standard rungs")

        uninhibit = self.base_tags[0][0]  # Uninhibit tag name
        inhibit = self.base_tags[1][0]  # Inhibit tag name
        toggle_inhibit = self.base_tags[2][0]  # ToggleInhibit tag name
        local_mode = self.base_tags[3][0]  # LocalMode tag name
        test_mode = self.base_tags[4][0]  # zz_Demo3D_TestMode tag name

        # Header rung
        header_rung = plc.Rung(
            controller=self.controller,
            text='NOP();',
            comment='// Emulation Logic Routine\n// Auto-generated by Indicon LLC\n// Do not modify.'
        )
        self._add_rung_to_standard_routine(header_rung)

        # Setup Rung
        setup_rung = plc.Rung(
            controller=self.controller,
            text=f'[XIC(S:FS)OTU({toggle_inhibit})OTU({test_mode}),MOV(0,{uninhibit})MOV(4,{inhibit})];',
            comment='// This routine is auto-generated by Indicon LLC.\n// Do not modify.'
        )
        self._add_rung_to_standard_routine(setup_rung)

        # Inhibit Logic Rung
        inhibit_logic_rung = plc.Rung(
            controller=self.controller,
            text=f'[XIO({toggle_inhibit})MOV({uninhibit},{local_mode}),XIC({toggle_inhibit})MOV({inhibit},{local_mode})];',
            comment='// Handle toggle inhibit.'
        )
        self._add_rung_to_standard_routine(inhibit_logic_rung)

        self._generate_module_inhibit_rungs()

    def _generate_base_tags(self) -> None:
        """Generate base tags common to all controllers."""
        if not self.base_tags:
            self.logger.debug("No base tags defined, skipping base tag generation.")
        self.logger.info("Generating base tags")
        for tag_name, datatype, description in self.base_tags:
            self.add_controller_tag(tag_name, datatype, description=description)

    def _generate_builtin_common(
        self,
        generation_type: plc.ModuleControlsType
    ) -> None:
        modules: list[plc.IntrospectiveModule] = mod.ModuleWarehouseFactory.filter_modules_by_type(
            self.generator_object.modules,
            generation_type
        )
        if not modules:
            self.logger.warning("No modules found, skipping builtin emulation for type %s.", generation_type.value)
            return

        self.logger.info("Generating built-in common emulation for %d modules of type %s", len(modules), generation_type.value)

        for module in modules:
            self._schedule_imports(module.get_required_imports())
            self.add_controller_tags(module.get_required_tags())
            self.add_safety_tag_mapping(*module.get_required_standard_to_safety_mapping())
            self.add_rungs(
                self.target_standard_program_name,
                self.emulation_standard_routine_name,
                module.get_required_standard_rungs()
            )
            self.add_rungs(
                self.target_safety_program_name,
                self.emulation_safety_routine_name,
                module.get_required_safety_rungs()
            )

    def _generate_custom_safety_routines(self) -> None:
        """Generate custom safety routines. Override in subclasses if needed."""
        pass

    def _generate_custom_safety_rungs(self) -> None:
        """Generate custom safety rungs. Override in subclasses if needed."""
        pass

    def _generate_custom_standard_routines(self) -> None:
        """Generate custom standard routines. Override in subclasses if needed."""
        pass

    def _generate_custom_standard_rungs(self) -> None:
        """Generate custom standard rungs. Override in subclasses if needed."""
        pass

    def _generate_custom_tags(self) -> None:
        """Generate custom tags. Override in subclasses if needed."""
        if not self.custom_tags:
            self.logger.debug("No custom tags defined, skipping custom tag generation.")
        self.logger.info("Generating custom tags")
        for tag_name, datatype, description, dimensions in self.custom_tags:
            self.add_controller_tag(tag_name, datatype, description=description, dimensions=dimensions)

    def _generate_module_inhibit_rungs(self) -> None:
        """Generate inhibit logic for modules."""
        if not self.emu_routine:
            raise ValueError("Emulation routine has not been created yet.")

        self.logger.debug("Generating module inhibit rungs")
        local_mode = self.base_tags[3][0]  # LocalMode tag name

        for module in self.generator_object.modules:
            if module.name == 'Local':
                continue
            inhibit_rung = self.generator_object.config.rung_type(
                controller=self.controller,
                text=f'SSV(Module,{module.name},Mode,{local_mode});',
                comment=f'// Inhibit logic for module {module.name}'
            )
            self._add_rung_to_standard_routine(inhibit_rung)

    def _import_safety_block_udts(self) -> None:
        """Import UDTs required for safety block emulation."""
        self.schema.add_import_from_file(
            file_location=r'docs\controls\emu\Demo3D_WDint_DataType.L5X',
            asset_types=['DataTypes']
        )
        self.schema.add_import_from_file(
            file_location=r'docs\controls\emu\Demo3D_CommOK_SBK_DataType.L5X',
            asset_types=['DataTypes']
        )

    def _schedule_imports(
        self,
        imports: List[tuple[str, List[str]]]
    ) -> None:
        """Helper to schedule imports in the modification schema.

        Args:
            imports: List of tuples (file_location, [asset_types])
        """
        for file_location, asset_types in imports:
            self.logger.debug(f"Scheduling import of {asset_types} from {file_location}")
            self.schema.add_import_from_file(
                file_location=file_location,
                asset_types=asset_types
            )

    def add_emulation_routine(
        self,
        program_name: str,
        routine_name: str,
        routine_description: str,
        call_from_main: bool = True,
        rung_position: int = -1
    ) -> plc.Routine:
        """Helper method to add an emulation routine to a program.

        Args:
            program_name: Name of the program to add routine to
            routine_name: Name of the new routine
            routine_description: Description for the routine
            call_from_main: Whether to add JSR call from main routine
            rung_position: Position to insert JSR call (-1 for end)

        Returns:
            Routine: The created routine
        """
        self.logger.debug(f"Adding emulation routine '{routine_name}' to program '{program_name}' to schema.")

        # Create the routine
        routine: plc.Routine = self.controller.config.routine_type(controller=self.controller)
        routine.name = routine_name
        routine.description = routine_description
        routine.clear_rungs()

        # Add routine to program
        self.schema.add_routine(
            program_name=program_name,
            routine=routine
        )

        # Add JSR call if requested
        if call_from_main:
            program: plc.Program = self.controller.programs.get(program_name)
            if program and program.main_routine:
                if program.main_routine.check_for_jsr(routine_name):
                    self.logger.debug(f"JSR to '{routine_name}' already exists in main routine of program '{program_name}'")
                else:
                    self.logger.debug(f"Adding JSR call to '{routine_name}' in main routine of program '{program_name}'")
                    jsr_rung = plc.Rung(
                        controller=self.controller,
                        text=f'JSR({routine_name},0);',
                        comment=f'Call the {routine_name} routine.'
                    )
                    self.schema.add_rung(
                        program_name=program_name,
                        routine_name=program.main_routine_name,
                        rung_number=rung_position,
                        new_rung=jsr_rung
                    )

        return routine

    def add_program_tag(
        self,
        program_name: str,
        tag_name: str,
        datatype: str,
        **kwargs
    ) -> plc.Tag:
        """Helper method to add a tag to a program.

        Args:
            program_name: Name of the program
            tag_name: Name of the tag
            datatype: Datatype of the tag
            **kwargs: Additional tag properties

        Returns:
            Tag: The created tag
        """
        self.logger.debug(f"Adding program tag: {tag_name} with datatype {datatype} to program {program_name}")

        tag = plc.Tag(
            controller=self.controller,
            name=tag_name,
            datatype=datatype,
            **kwargs
        )

        self.schema.add_program_tag(
            program_name=program_name,
            tag=tag
        )

        return tag

    def add_controller_tag(
        self,
        tag_name: str,
        datatype: str,
        description: str = "",
        constant: bool = False,
        external_access: str = "Read/Write",
        tag_type: str = 'Base',
        **kwargs
    ) -> plc.Tag:
        """Helper method to add a controller-scoped tag.

        Args:
            tag_name: Name of the tag
            datatype: Datatype of the tag
            **kwargs: Additional tag properties

        Returns:
            Tag: The created tag
        """
        self.logger.debug(f"Adding controller tag: {tag_name} with datatype {datatype} to schema.")

        tag = self.controller.config.tag_type(
            controller=self.controller,
            name=tag_name,
            datatype=datatype,
            description=description,
            constant=constant,
            external_access=external_access,
            tag_type=tag_type,
            **kwargs
        )

        self.schema.add_controller_tag(tag)
        return tag

    def add_controller_tags(
        self,
        tags: List[dict]
    ) -> None:
        """Helper method to add multiple controller-scoped tags.

        Args:
            tags: List of tag dictionaries with keys matching Tag properties
        """
        for tag_info in tags:
            self.add_controller_tag(**tag_info)

    def add_rung(
        self,
        program_name: str,
        routine_name: str,
        new_rung: plc.Rung,
        rung_number: Optional[int] = None
    ) -> None:
        """Helper method to add a rung to a routine.

        Args:
            program_name: Name of the program
            routine_name: Name of the routine
            new_rung: The rung to add
            rung_number: Position to insert the rung (-1 for end)
        """

        self.schema.add_rung(
            program_name=program_name,
            routine_name=routine_name,
            rung_number=rung_number,
            new_rung=new_rung
        )

    def add_rungs(
        self,
        program_name: str,
        routine_name: str,
        new_rungs: List[plc.Rung],
        rung_number: Optional[int] = None
    ) -> None:
        """Helper method to add multiple rungs to a routine.

        Args:
            program_name: Name of the program
            routine_name: Name of the routine
            new_rungs: List of rungs to add
            rung_number: Position to insert the first rung (-1 for end)
        """
        for i, rung in enumerate(new_rungs):
            position = rung_number + i if rung_number is not None and rung_number >= 0 else -1
            self.add_rung(
                program_name=program_name,
                routine_name=routine_name,
                new_rung=rung,
                rung_number=position
            )

    def add_safety_tag_mapping(
        self,
        standard_tag: str,
        safety_tag: str,
    ) -> None:
        """Helper method to add a safety tag mapping.

        Args:
            standard_tag: Name of the standard tag
            safety_tag: Name of the safety tag
        """
        if not standard_tag or not safety_tag:
            return
        self.schema.add_safety_tag_mapping(
            std_tag=standard_tag,
            sfty_tag=safety_tag
        )

    def block_routine_jsr(
        self,
        program_name: str,
        routine_name: str
    ) -> None:
        """Helper method to block a JSR call to a routine.

        Args:
            program_name: Name of the program
            routine_name: Name of the routine
        """
        self.logger.debug(f"Blocking JSR call to routine '{routine_name}' in program '{program_name}'")
        ...

    @abstractmethod
    def generate_custom_module_emulation(self) -> None:
        """Generate module-specific emulation logic."""
        pass

    @abstractmethod
    def remove_base_emulation(self) -> None:
        """Remove the base emulation logic common to all controllers."""
        pass

    @abstractmethod
    def remove_module_emulation(self) -> None:
        """Remove module-specific emulation logic."""
        pass

    @abstractmethod
    def validate_controller(self) -> bool:
        """Validate that the controller is compatible with this generator.

        Returns:
            bool: True if controller is valid for this generator type.

        Raises:
            ValueError: If controller validation fails.
        """
        pass

    def generate_custom_logic(self) -> None:
        """Generate custom emulation logic. Override in subclasses if needed."""
        pass

    def generate_emulation_logic(self) -> plc.ControllerModificationSchema:
        """Main entry point to generate emulation logic.

        Returns:
            ControllerModificationSchema: The modification schema with all changes.
        """
        self.logger.info(f"Starting emulation generation for {self.controller.name}")

        # Validate controller
        if not self.validate_controller():
            raise ValueError(f"Controller {self.controller.name} is not valid for {self.controller_type} emulation")

        # Generate emulation logic
        self._generate_base_emulation()
        self.generate_custom_module_emulation()
        self.generate_custom_logic()

        # Execute the schema
        self.schema.execute()

        self.logger.info(f"Emulation generation completed for {self.controller.name}")
        return self.schema

    def remove_emulation_logic(self) -> plc.ControllerModificationSchema:
        """Remove previously added emulation logic.

        Returns:
            ControllerModificationSchema: The modification schema with all removals.
        """
        self.logger.info(f"Starting emulation removal for {self.controller.name}")

        # Remove emulation logic
        self.remove_base_emulation()
        self.remove_module_emulation()
        self.remove_custom_logic()

        # Execute the schema to remove added elements
        self.schema.execute()

        self.logger.info(f"Emulation removal completed for {self.controller.name}")
        return self.schema

    def get_modules_by_type(self, module_type: str) -> List[plc.Module]:
        """Get all modules of a specific type.

        Args:
            module_type: The module type to filter by

        Returns:
            List[Module]: List of matching modules
        """
        mods = [module for module in self.controller.modules if module.type_ == module_type]
        self.logger.info('Found %d modules of type %s...', len(mods), module_type)
        return mods

    def get_modules_by_description_pattern(self, pattern: str) -> List[plc.Module]:
        """Get modules matching a description pattern.

        Args:
            pattern: Pattern to match in module description

        Returns:
            List[Module]: List of matching modules
        """
        mods = [m for m in self.controller.modules if m.description and pattern in m.description]
        self.logger.info('Found %d modules matching description pattern "%s"...', len(mods), pattern)
        return mods

    def remove_custom_logic(self) -> None:
        """Remove custom emulation logic."""
        pass

    def remove_controller_tag(
        self,
        tag_name: str
    ) -> None:
        """Helper method to remove a controller-scoped tag.

        Args:
            tag_name: Name of the tag to remove
        """
        self.logger.debug(f"Removing controller tag '{tag_name}'")

        self.schema.remove_controller_tag(
            tag_name=tag_name
        )

    def remove_datatype(
        self,
        datatype_name: str
    ) -> None:
        """Helper method to remove a datatype from the controller.

        Args:
            datatype_name: Name of the datatype to remove
        """
        self.logger.debug(f"Removing datatype '{datatype_name}' from controller")

        self.schema.remove_datatype(
            datatype_name=datatype_name
        )

    def remove_program_tag(
        self,
        program_name: str,
        tag_name: str
    ) -> None:
        """Helper method to remove a tag from a program.

        Args:
            program_name: Name of the program
            tag_name: Name of the tag to remove
        """
        self.logger.debug(f"Removing tag '{tag_name}' from program '{program_name}'")

        self.schema.remove_program_tag(
            program_name=program_name,
            tag_name=tag_name
        )

    def remove_routine(
            self,
            program_name: str,
            routine_name: str
    ) -> None:
        """Helper method to remove a routine from the controller.

        Args:
            program_name: Name of the program containing the routine
            routine_name: Name of the routine to remove
        """
        self.logger.debug(f"Removing routine '{routine_name}' from controller")

        self.schema.remove_routine(
            program_name,
            routine_name
        )
